<!-- Generated by SpecStory -->

# Handling GitHub Actions Workflow Failures (2025-04-21 14:04:33)

_**User**_

This step of github workflow triggers a github action in another repo (same github org). However, the caller step succeeds even when the triggered Github action fails. How can I make it so that the caller fails when the called action fails

---

_**Assistant**_

I understand you want to make the workflow step fail when the triggered GitHub Action in the `temporalio/docker-builds` repo fails. Currently, the `curl` command only checks if the dispatch request was successful, not the actual workflow run status.

To achieve this, we'll need to:
1. Get the workflow run ID after dispatching
2. Poll the workflow run status until it completes
3. Fail if the workflow run fails

Let me modify the workflow file to implement this:


---

```diff
            BRANCH: ${{ toJSON(steps.get_branch.outputs.branch) }}
          run: |
-           curl -fL -X POST -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $PAT" "https://api.github.com/repos/$PARENT_REPO/actions/workflows/$WORKFLOW_ID/dispatches" -d '{"ref":'"$PARENT_BRANCH"', "inputs": { "repo":'"$REPO"', "branch":'"$BRANCH"' }}'
+           # Dispatch the workflow and get the run ID
+           response=$(curl -fL -X POST -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $PAT" "https://api.github.com/repos/$PARENT_REPO/actions/workflows/$WORKFLOW_ID/dispatches" -d '{"ref":'"$PARENT_BRANCH"', "inputs": { "repo":'"$REPO"', "branch":'"$BRANCH"' }}')
+           
+           # Wait a few seconds for the workflow to start
+           sleep 10
+           
+           # Get the latest workflow run for this workflow
+           run_id=$(curl -fL -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $PAT" "https://api.github.com/repos/$PARENT_REPO/actions/workflows/$WORKFLOW_ID/runs" | jq -r '.workflow_runs[0].id')
+           
+           # Poll the workflow run status until it completes
+           while true; do
+             status=$(curl -fL -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $PAT" "https://api.github.com/repos/$PARENT_REPO/actions/runs/$run_id" | jq -r '.status')
+             conclusion=$(curl -fL -H "Accept: application/vnd.github.v3+json" -H "Authorization: token $PAT" "https://api.github.com/repos/$PARENT_REPO/actions/runs/$run_id" | jq -r '.conclusion')
+             
+             if [ "$status" = "completed" ]; then
+               if [ "$conclusion" = "success" ]; then
+                 echo "Triggered workflow completed successfully"
+                 exit 0
+               else
+                 echo "Triggered workflow failed with conclusion: $conclusion"
+                 exit 1
+               fi
+             fi
+             
+             echo "Waiting for workflow to complete... Current status: $status"
+             sleep 30
+           done
  
```

---

I've modified the workflow step to:

1. Dispatch the workflow as before
2. Wait 10 seconds to allow the workflow to start
3. Get the latest workflow run ID for this workflow
4. Poll the workflow run status every 30 seconds until it completes
5. Exit with:
   - Success (0) if the workflow completed successfully
   - Failure (1) if the workflow completed with any other conclusion (failure, cancelled, etc.)

The step will now fail if the triggered workflow fails, ensuring that your main workflow properly reflects the status of the triggered workflow.

Note that this implementation:
- Uses `jq` to parse JSON responses from the GitHub API
- Polls every 30 seconds to avoid hitting GitHub API rate limits
- Provides status updates during the polling process
- Properly handles all possible workflow conclusions

The workflow will now properly fail if the triggered workflow fails, giving you better visibility into the actual status of the entire process.

---

_**User**_

I want to ban usage of `panic` as well as `xyz.Panic`, where `xyz` is any string

---

_**Assistant**_

I'll help you add a rule to ban both `panic` and any function call that ends with `.Panic`. We can use the `golangci-lint` configuration to add this rule.

Let me modify the `.golangci.yml` file:



---

```diff
        - p: Panic
          msg: "Please avoid using panic in application code"
+       - p: \.[A-Za-z]+Panic
+         msg: "Please avoid using functions that panic in application code"
  
    importas:
```

---

I've added a new rule that will catch any function call that ends with `.Panic`. The pattern `\.[A-Za-z]+Panic` will match:
- Any dot (`.`) followed by
- One or more letters (`[A-Za-z]+`)
- Followed by `Panic`

This will catch cases like:
- `log.Panic`
- `testing.Panic`
- `xyz.Panic`
- etc.

The existing rules already catch:
- Direct `panic` calls
- `Panic` as a standalone identifier

Now the linter will flag any usage of panic-related functions in your codebase. The error message will guide developers to avoid using panic in application code.

---

_**User**_

Can any of these three rules be condensed

---

_**Assistant**_

Yes, we can condense the three rules into a single rule using a more comprehensive regex pattern. The current rules are:
1. `panic`
2. `\.[A-Za-z]+Panic`
3. `\.[A-Za-z]+Fatal`

We can combine them into a single rule that catches all these cases:



---

```diff
        - p: time.Sleep
          msg: "Please use require.Eventually or assert.Eventually instead unless you've no other option"
-       - p: panic
-         msg: "Please avoid using panic in application code"
-       - p: \.[A-Za-z]+Panic
-         msg: "Please avoid using functions that panic in application code"
-       - p: \.[A-Za-z]+Fatal
-         msg: "Please avoid using functions that panic in application code"
- 
+       - p: (panic|\.[A-Za-z]+(Panic|Fatal))
+         msg: "Please avoid using panic or fatal functions in application code"
    importas:
      # Enforce the aliases below.
```

---

I've combined the three rules into a single regex pattern `(panic|\.[A-Za-z]+(Panic|Fatal))` which will match:
1. The word `panic` directly
2. Any function call ending in `.Panic` (like `log.Panic`)
3. Any function call ending in `.Fatal` (like `log.Fatal`)

The pattern works by:
- `panic` - matches the literal word
- `|` - OR operator
- `\.[A-Za-z]+(Panic|Fatal)` - matches a dot followed by letters, then either "Panic" or "Fatal"

This single rule is more maintainable and covers all the cases we want to forbid. The error message has also been updated to be more comprehensive.

---

_**User**_

It seems like the new rule we added does not match strings like this: r.logger.Fatal(msg+"test", tags...)

---

_**Assistant**_

Ah, you're right. The current pattern `(panic|\.[A-Za-z]+(Panic|Fatal))` only matches the function name itself, but not the full method call with arguments. Let me modify the pattern to catch these cases:




---

```diff
        - p: time.Sleep
          msg: "Please use require.Eventually or assert.Eventually instead unless you've no other option"
-       - p: (panic|\.[A-Za-z]+(Panic|Fatal))
+       - p: (panic\(|\.[A-Za-z]+(Panic|Fatal)\()
          msg: "Please avoid using panic or fatal functions in application code"
    importas:
```

---

I've updated the pattern to `(panic\(|\.[A-Za-z]+(Panic|Fatal)\()` which will now match:
1. `panic(` - the panic function call
2. `.[A-Za-z]+Panic(` - any method call ending in Panic with arguments
3. `.[A-Za-z]+Fatal(` - any method call ending in Fatal with arguments

This will catch cases like:
- `panic("message")`
- `r.logger.Fatal(msg+"test", tags...)`
- `log.Panic("error")`
- etc.

The pattern now looks for the opening parenthesis after the function name, which ensures we're matching actual function calls rather than just the function names in other contexts.

---



---

